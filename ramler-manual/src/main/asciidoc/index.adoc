= Ramler User Manual 
OPS4J 
:doctype: book 
:toc: left 
:toclevels: 3
:toc-position: left 
:toc-title: OPS4J Ramler 
:numbered:

// Push titles down one level
:leveloffset: 1

++++ 
<link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/font-awesome/3.1.0/css/font-awesome.min.css">
++++

:icons: font

= Introduction

== Purpose

Ramler is a code and documentation generator for RESTful APIs defined by a 
https://github.com/raml-org/raml-spec/blob/master/versions/raml-10/raml-10.md[RAML 1.0 specification].

The RESTful API Modeling Language (http://www.raml.org[RAML]) is an open standard for API specifications.

Ramler supports a model-first strategy for designing, implementing and documenting a RESTful API.

Given a RAML specification, Ramler generates Java entity classes and resource interfaces compliant 
with JAX-RS 2.0. The generated code can be fine-tuned using some custom RAML annotations defined by
Ramler. Ramler contains special support for https://jersey.github.io/[Jersey] with 
https://github.com/FasterXML/jackson-databind[Jackson data binding].

Ramler also generates a link:registry/[static HTML 5 website] with hyperlinked and searchable documentation directly from a RAML specification. 

You can generate TypeScript interfaces from RAML type definitions (beta).

In addition, Ramler converts RAML 1.0 specifications to OpenAPI 3.0 specifications, for the benefit of 
other tools which are based on OpenAPI.

== Prerequisites

Ramler requires Java 8 and is best used with Maven 3.3.1 or higher. 

The HTML code generator is based on Node.js and npm, but this dependency is encapsulated by the
https://github.com/eirslett/frontend-maven-plugin[`frontend-maven-plugin`]. 

While Maven is not a strict requirement, it is the easiest way to use Ramler. If you prefer other
build tools, you will have to write some glue code to invoke Ramler APIs.

== Credits

* Ramler includes source code for some utility classes from 
https://github.com/mulesoft/raml-for-jax-rs[`raml-for-jax-rs`], but the Java code
generator is a largely independent implementation based on the 
https://github.com/raml-org/raml-java-parser[`raml-java-parser`].

* The HTML generator is a heavily modified copy of https://github.com/lord/slate[Slate], with all 
Ruby dependencies replaced by Java or JavaScript tools or libraries. 
HTML templates are based on http://www.trimou.org[Trimou].

* Markdown content is rendered as HTML using https://github.com/sirthias/pegdown[Pegdown].

= Working with Ramler

== Overview

Using Ramler, a RESTful API can be implemented in the following steps:

* Create a RAML 1.0 model of your API. It is recommended to use the 
https://atom.io/[Atom] editor with the 
http://apiworkbench.com/[API Workbench] plugin for this step. 

* Generate Java entity classes and JAX-RS resource interfaces from the RAML model, either programmatically, or using the `ramler-maven-plugin`.

* Build a library from the generated classes and include this library in your Java application.

* Manually create JAX-RS resource classes implementing the interfaces generated by Ramler.

* Generate HTML documentation from the RAML model, either programmatically, or using the 
`ramler-maven-plugin`. You can use the default templates and styles or provide your own.

== Using the Maven Plugin

Here is an example of using the `raml-maven-plugin` to generate Java code and a static website:

[source,xml]
----
<dependencies>
    <dependency>
        <groupId>javax</groupId>
        <artifactId>javaee-api</artifactId>
        <version>7.0</version>
        <scope>provided</scope>
    </dependency>
</dependencies>

<build>
    <plugins>
        <plugin>
            <groupId>org.ops4j.ramler</groupId>
            <artifactId>ramler-maven-plugin</artifactId>
            <version>${project.version}</version>
            <configuration>
                <package>org.ops4j.ramler.samples.registry</package>
                <model>src/test/resources/raml/registry.raml</model>
            </configuration>
            <executions>
                <execution>
                    <id>generate</id>
                    <goals>
                        <goal>java</goal>
                        <goal>html</goal>
                    </goals>
                </execution>
            </executions>
        </plugin>
        <plugin>
            <artifactId>maven-javadoc-plugin</artifactId>
            <configuration>
                <doclet>ch.raffael.doclets.pegdown.PegdownDoclet</doclet>
                <docletArtifact>
                    <groupId>ch.raffael.pegdown-doclet</groupId>
                    <artifactId>pegdown-doclet</artifactId>
                    <version>1.3</version>
                </docletArtifact>
                <useStandardDocletOptions>true</useStandardDocletOptions>
            </configuration>
        </plugin>
    </plugins>
</build>
----

== Limitations

Please note the following limitations when using Ramler:

* RAML 0.8 is not supported. Ramler requires a RAML 1.0 specification.
* Only native RAML types are supported. Ramler cannot handle type definitions based on JSON Schema or
  XML schema.
* Examples in the RAML specification must use YAML syntax to be rendered in the generated website.
  Literal JSON is not supported.
* Ramler supports at most one level of nested subresources. Each top-level resource is turned into a
JAX-RS resource class. All methods of subresources of the given top-level resource will be turned
into methods of the same JAX-RS resource class.
  
= Java Code Generator

== Overview

Given a RAML specification, the Java code generator creates plain old Java objects (POJO) with getters
and setters for each user-defined object type and a Java interface for each resource, with methods corresponding
to the HTTP methods defined in RAML.

RAML descriptions are converted to Javadoc comments.

Example: 

This RAML type

[source,yaml]
----
Person:
  firstName: string
  lastName: string
----
    
will generate the following Java class:

[source,java]
----
public class Person {

    private String firstName;
    private String lastName;

    public String getFirstname() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastname(String lastName) {
        this.lastName = lastName;
    }
}
----    

By default, the Java field name will be equal to the RAML property name and the accessor method names will follow
the usual Java bean naming conventions. The getter for a boolean property `foo` is named `isFoo()`.

If the property name conflicts with a Java keyword, the field name is prefixed with a `$`.

Custom field names can be specified with the RAML annotation `(codeName)`. When the Ramler configuration 
property `jacksonPropertyName` is set, Ramler will add a `JsonProperty` annotation to the field so that
Jackson will map the Java field to the JSON property indicated by the annotation.

== Scalar Property Mapping

Properties of an object type with a scalar RAML type are mapped to fields with Java types 
according to the following table:

|===
| RAML type       | Format        | Required          | Java type

| `boolean`         |               | yes               | `boolean`
| `boolean`         |               | no                | `java.lang.Boolean`
| `date-only`       |               |                   | `java.time.LocalDate`
| `datetime`        |               |                   | `java.time.ZonedDateTime`
| `datetime-only`   |               |                   | `java.time.LocalDateTime`
| `file`            |               |                   | `java.io.InputStream`
| `integer`         | `int64, long`   | yes             | `long`
| `integer`         | `int64, long`   | no              | `java.lang.Long`
| `integer`         | `int8, int16, int32, int`   | yes   | `int`
| `integer`         | `int8, int16, int32, int`   | no    | `java.lang.Integer`
| `null`            |               |                   | `java.lang.Object`
| `number`          | `double`      | yes               | `double`
| `number`          | `double`      | no                | `java.lang.Double`
| `number`          | `float`       | yes               | `float`
| `number`          | `float`       | no                | `java.lang.Float`
| `string`          |               |                   | `java.lang.String` or `enum` type
| `time-only`       |               |                   | `java.time.LocalTime`
|===


== Structured Property Mapping

=== Overview

Properties of an object type with a structured RAML type are mapped to fields with Java types 
according to the following table:

|===
| RAML type         | Java type

| `any`             | `java.lang.Object`
| `array`           | `java.util.List<I>`
| `object`          | POJO or `Map<String, Object>`
| `union`           | wrapper class
|===


=== Array Types

For array types, the type argument `I` of the Java `List` type will be the Java type of the array item type.

=== Object Types

For object types, the referenced type will be the generated Java class if the type has any properties. A RAML `object`
type without any specified properties will be mapped to `Map<String, Object>`, to allow for any JSON properties
at run-time that are unknown at modelling time.

=== Union Types

Properties of union types are only supported as a reference to a user-defined union type, where all alternatives
are user-defined object types.

Example:

[source,yaml]
----
Favourite:
  type: City | Dog
  
User:
  properties:
    login: string
    favourite: Favourite
----
        
The `Favourite` union type will be mapped to a Java wrapper class, optionally with a custom Jackson (de)serializer, 
when the configuration property `jacksonUnion` is set to `true`.

[source,java]
----
@JsonSerialize(using = FavouriteSerializer.class)
@JsonDeserialize(using = FavouriteDeserializer.class)
public class Favourite {

    private Object value;

    public Object value() {
        return value;
    }

    public boolean isCity() {
        return (value instanceof City);
    }

    public City getCity() {
        return ((City) value);
    }

    public void setCity(City city) {
        this.value = city;
    }

    public boolean isDog() {
        return (value instanceof Dog);
    }

    public Dog getDog() {
        return ((Dog) value);
    }

    public void setDog(Dog dog) {
        this.value = dog;
    }
}
----
        
== Enumeration Types

A user-defined RAML type with base type `string` and an `enum` facet will be mapped to a Java `enum` class 
with constants corresponding to the value list of the `enum` facet.

[source,yaml]
----
Colour:
  type: string
  enum:
  - lightBlue
  - red
----
 
[source,java]
----
public enum Colour {

    LIGHT_BLUE("lightBlue"),
    RED("red");
    private final String value;

    private Colour(String value) {
        this.value = value;
    }

    public String value() {
        return value;
    }

    public static Colour fromValue(String value) {
        for (Colour v: Colour.values()) {
            if (v.value.equals(value)) {
                return v;
            }
        }
        throw new IllegalArgumentException(value);
    }
}
----

Since RAML 1.0 does not allow for any facets or annotations on `enum` values, Ramler provides an `(enum)`
annotation as an alternative.

[source,yaml]
----
Colour:
  type: string
  (r.enum):
    values:
      - name: lightBlue
        description: Colour of the sky.
      - name: red
        description: Colour of tomatoes.
----

[source,java]
----
public enum Colour {

    /**
     * Colour of the sky.
     */
    LIGHT_BLUE("lightBlue"),

    /**
     * Colour of tomatoes.
     */
    RED("red");

    // further members omitted
}    
----

When the Ramler configuration property `jacksonPropertyName` is set, Ramler will add a `JsonProperty` annotation 
to each enum constant, so Jackson will map the Java constant to the correct JSON string.

== Inheritance

A user-defined RAML object type can have one or more base types. Since Java does not support multiple
inheritance, Ramler maps the first base type as Java base class and adds all properties from any
additional base types directly to the Java class.

Example:

[source,yaml]
----
A:
  properties:
    a1: string
    a2: string
B:
  properties:   
    b1: int
    b2: int
C:
  type: [A, B]
  properties
    c1: string    
----

[source,java]
----
public class C extends A {
    private int b1;
    private int b2;
    private String c1;
	// methods omitted
}
----

== Discriminators

A RAML type with a discriminator is mapped to a Java class with a public string constant `DISCRIMINATOR` 
defining the discriminator value. By default, the discriminator property is immutable, it only has a getter which
returns the constant.

In some situations, e.g. for provoking validation errors in tests, it may be required to have mutable 
discriminator properties. This feature can be enabled by setting the Ramler configuration property
`discriminatorMutable` to `true`.

Example:

[source,yaml]
----         
Person:
  discriminator: objectType
  discriminatorValue: p
  properties:
    firstName: string
    lastName: string
    objectType: string
Employee:
  discriminatorValue: e
  type: Person
  properties:
    department: string
----

[source,java]
----
public class Person {

    public final static String DISCRIMINATOR = "p";
    private String firstname;
    private String lastname;

    public String getObjectType() {
        return Person.DISCRIMINATOR;
    }

    public String getFirstname() {
        return firstname;
    }

    public void setFirstname(String firstname) {
        this.firstname = firstname;
    }

    public String getLastname() {
        return lastname;
    }

    public void setLastname(String lastname) {
        this.lastname = lastname;
    }
}

public class Employee extends Person {

    public final static String DISCRIMINATOR = "e";
    private String department;

    public String getObjectType() {
        return DISCRIMINATOR;
    }

    public String getDepartment() {
        return department;
    }

    public void setDepartment(String department) {
        this.department = department;
    }
}
----

Same example with mutable discriminators:

[source,java]
----
public class Person {

    public final static String DISCRIMINATOR = "p";
    private String objectType;
    private String firstname;
    private String lastname;

    public Person() {
        setObjectType(DISCRIMINATOR);
    }

    public String getObjectType() {
        return objectType;
    }

    public void setObjectType(String objectType) {
        this.objectType = objectType;
    }

    public String getFirstname() {
        return firstname;
    }

    public void setFirstname(String firstname) {
        this.firstname = firstname;
    }

    public String getLastname() {
        return lastname;
    }

    public void setLastname(String lastname) {
        this.lastname = lastname;
    }
}

public class Employee extends Person {

    public final static String DISCRIMINATOR = "e";
    private String department;

    public Employee() {
        setObjectType(DISCRIMINATOR);
    }

    public String getDepartment() {
        return department;
    }

    public void setDepartment(String department) {
        this.department = department;
    }
}
----

== Polymorphic Deserialization

For RAML types with discriminators, the generated Java classes can be enriched with Jackson annotations to 
support polymorphic deserialization. These annotations enable the Jackson `ObjectMapper` to select
the appropriate Java class for unmarshalling a JSON object based on its discriminator property.

This feature can be enabled by setting the Ramler configuration property
`jacksonTypeInfo` to `true`.

In the above example, some annotations would be added to the `Person` class.

[source,java]
----
@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.EXISTING_PROPERTY, property = "objectType")
@JsonSubTypes({
    @JsonSubTypes.Type(Employee.class)
})
public class Person {
    // members omitted
}
----

== Specialization and Generics

In RAML, derived types can specialize a base type property with a narrower type, e.g.

[source,yaml]
----
Result:
  properties:
    result: any
    message?: string
PersonResult:
  type: Result
  properties:
    result: Person
    message?: string
----

This does not map very well to Java, because `PersonResult.setResult(Person)` does not override 
`Result.setResult(Object)`.

In Java, it would be more suitable to model this situation with generics, e.g. `Result<T>.setResult(T)`.

To support this use case, Ramler provides three annotations `typeArgs`, `typeVar` and `typeVars` to add sufficient 
information for generating Java generics and parameterized types.

`typeVars` defines the parameter list of a generic type. `typeVar` references a type parameter from
the body of a generic type. `typeArgs` defines the argument list for a parameterized type, where the size
of the argument list must match the size of the parameter list of the underlying generic type.

Using these annotations, the given example can be rewritten as

[source,yaml]
----
Result:
  (typeVars): [T]
  properties:
    result: 
      (typeVar): T
      type: any
    message?: string
PersonResult:
  type: Result
  (typeArgs): [Person] 
----

and the generated Java classes will look like this:

[source,java]
----
public class Result<T> {

    private T result;
    private String message;

    public T getResult() {
        return result;
    }

    public void setResult(T result) {
        this.result = result;
    }
    
    public String getMessage() {
        return message;
    }
    
    public void setMessage(String message) {
        this.message = message;
    }
}

public class PersonResult extends Result<Person> {
}
----


== Resource Interfaces

RAML resources can have subresources nested to any depth. 

To simplify code generation, Ramler currently only supports two nesting levels, always mapping the first
level to a resource interface with a `@Path` annotation and the second level to a method of the same interface
with an additional `@Path` annotation.

Ramler does not impose any restrictions on the number of relative path components used at each nesting level.

For the generated Java interface, the class name is a camel-case version of the resource path name with a 
configurable suffix. The default interface name suffix is `Resource`. The suffix can be changed by setting
the Ramler configuration property `interfaceNameSuffix`.

The Java method name is the camel-case display name of the corresponding RAML method, if present, or the
HTTP method name otherwise.

[source,yaml]
----
/person:
  get:
    displayName: Find persons
    responses:
      200:
        body:
          type: Person[]
  /address:
    get:        
      displayName: Get address
      responses:
        200:
          body:
            type: Address
----
      
[source,java]
----
@Path("/person")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public interface PersonResource {

    /** Find persons */
    @GET
    List<Person> findPersons();

    /** Get address */
    @Path("/address")
    @GET
    Address getAddress();
}
----

For more fine-grained control over interface and method names, Ramler provides the `codeName` annotation.
The value of this annotation, if present, takes precedence over the `displayName` facet. The configured
interface name suffix is always appended last, even when `codeName` is set.

== Resource Methods

The Java return type of a method is always determined by the RAML type of the first response, or `void` otherwise.

A method body type, if present, gives rise to a Java method parameter with the corresponding Java type, unless the 
response media type is `multipart/form-data`.

In this case, each property of the body type gives rise to a Java method parameter annotated
by `@FormDataParam`. A RAML parameter of type `file` gives rise to two Java parameters of types
`java.io.InputStream` and `org.glassfish.jersey.media.multipart.FormDataContentDisposition`.

Each RAML query parameter gives rise to a Java method parameter annotated by `@QueryParam`.

Each RAML URI parameter gives rise to a Java method parameter annotated by `@PathParam`.

For all `@*Param` annotations, the unnamed annotation argument corresponds to the RAML parameter name.

Ramler does not currently support header or matrix parameters.

== Multiple Media Types

For a resource method with a response body that supports multiple media types, Ramler will generate a separate Java method 
for each media type and add a `@Produces` annotation to each method not matching the media type defined at class level.

It is recommended to specify the generated method name with a `codeName` annotation to the alternative media type. By default,
Ramler will simply add a numerical suffix to the RAML method name.

Example:

[source,yaml]
----
/anything:
  get:
    responses:
      200:
        body:
          application/json:
            type: object
          text/csv:
            (r.codeName): getCsv
            type: string
----

[source,java]
----

@Path("/anything")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public interface AnythingResource {

    @GET
    Map<String, Object> get();

    @GET
    @Produces("text/csv")
    String getCsv();

}
----

= HTML Generator

The HTML generator generates a static website with three columns for types and resources, details and examples.

You can customize the layout by overriding the included web resources or even by adapting the 
http://www.trimou.org[Trimou] templates used to generate output from the parsed API model.

To do so, set the configuration properties `webResourceDir` or `templateDir`, respectively.

= TypeScript Code Generator

== Overview

The TypeScript code generator generates interfaces or type aliases for each user-defined RAML type. It does not yet generate
any code for RAML resources or methods.

Example: 

This RAML type

[source,yaml]
----
Person:
  firstName: string
  lastName: string
----
    
will generate the following TypeScript interface:

[source,typescript]
----
export interface Person {
    firstName: string;
    lastName: string;
}
----    


== Scalar Property Mapping

Properties of an object type with a scalar RAML type are mapped to fields with TypeScript types 
according to the following table:

|===
| RAML type         | TypeScript type

| `boolean`         | `boolean`
| `date-only`       | `string`
| `datetime`        | `string`
| `datetime-only`   | `string`
| `file`            | not supported
| `integer`         | `number`
| `null`            | `null`
| `number`          | `number`
| `string`          | `string` or `enum` type
| `time-only`       | `string`
|===

== Structured Property Mapping

=== Overview

Properties of an object type with a structured RAML type are mapped to fields with TypeScript types 
according to the following table:

|===
| RAML type         | TypeScript type

| `any`             | `any`
| `array`           | `Array<I>`
| `object`          | interface or `object`
| `union`           | type alias
|===


=== Array Types

For array types, the type argument `I` of the TypeScript `Array` type will be the TypeScript type of the array item type.

=== Object Types

For object types, the referenced type will be the generated Java class if the type has any properties. A RAML `object`
type without any specified properties will be mapped to `object`, to allow for any JSON properties
at run-time that are unknown at modelling time.

=== Union Types

RAML Union types are mapped to an alias for a corresponding TypeScript union type.

Example:

[source,yaml]
----
Favourite:
  type: City | Dog
----
        
[source,typescript]
----
export type Favourite = City | Dog;
----
        
== Enumeration Types

A user-defined RAML type with base type `string` and an `enum` facet will be mapped to a TypeScript `enum` type 
with members corresponding to the upper-cased values list of the `enum` facet, each initialized with the
respective literal value.

[source,yaml]
----
Colour:
  type: string
  enum:
  - lightBlue
  - red  
----
 
[source,typescript]
----
export enum Colour {
    LIGHT_BLUE = 'lightBlue',
    RED = 'red'
}
----

== Specialization and Generics

Ramler defines a number of annotation to model the equivalent of generic types in RAML. See <<_specialization_and_generics>>
for more details.

Example:

The following RAML definitions 

[source,yaml]
----
Result:
  (typeVars): [T]
  properties:
    result: 
      (typeVar): T
      type: any
    message?: string
PersonResult:
  type: Result
  (typeArgs): [Person] 
----

will be mapped to

[source,typescript]
----
export interface Result<T> {
    result: T;
    message: string;
}

export interface PersonResult extends Result<Person> {
}
----

= Maven Plugin

== html Goal

|===
| Parameter     | Type          | Meaning

| `model`         | `String`        | RAML specification file, relative to `${project.basedir}`

| `outputDir`     | `File`          | Output directory for generated code. 
Default: `${project.build.directory}/generated-sources/ramler`

| `webResourceDir` | `File` | Directory with web resources to be used instead of the built-in resources.

| `templateDir` | `File` | Directory with Trimou templates which take precedence over the built-in templates.
The entry template is named `api.trimou.html`.

|===


== java Goal

|===
| Parameter     | Type          | Meaning

| `model`         | `String`        | RAML specification file, relative to `${project.basedir}`

| `packageName`   | `String`        | Fully qualified package name for generated Java sources. 
The generated classes will be located in subpackages `model` and `api`

| `outputDir`     | `File`          | Output directory for generated code. 
Default: `${project.build.directory}/generated-sources/ramler`

| `discriminatorMutable` | `boolean` | Should discriminator properties be mutable?
Default: `false`

| `interfaceNameSuffix` | `String` | Suffix for interface names. 
This suffix is appended to the code name of a resource. The code
name is either specified explicitly by the `(codeName)` annotation, or implicitly by
the resource name, converted to camel case.
Default: `Resource`

| `jacksonPropertyName` | `boolean` |  Should Java classes include `JsonProperty` annotations 
for properties with illegal Java names? Will also annotate `enum` constants.
Default: `false`

| `jacksonTypeInfo` | `boolean` |  Should Java classes include `JsonTypeInfo` annotations for type hierarchies?
Default: `false`

| `jacksonUnion` | `boolean` |  Should Java classes include `JsonSerialize` and `@JsonDeserialize` 
annotations for union type wrappers?
Default: `false`

|===


== java-test Goal  

|===
| Parameter     | Type          | Meaning

| `model`         | `String`        | RAML specification file, relative to `${project.basedir}`
| `packageName`   | `String`        | Fully qualified package name for generated Java sources. 
The generated classes will be located in subpackages `model` and `api`

| `outputDir`     | `File`          | Output directory for generated code. 
Default: `${project.build.directory}/generated-test-sources/ramler`

| `discriminatorMutable` | `boolean` | Should discriminator properties be mutable?
Default: `false`

| `interfaceNameSuffix` | `String` | Suffix for interface names. 
This suffix is appended to the code name of a resource. The code
name is either specified explicitly by the `(codeName)` annotation, or implicitly by
the resource name, converted to camel case.
Default: `Resource`

| `jacksonPropertyName` | `boolean` |  Should Java classes include `JsonProperty` annotations 
for properties with illegal Java names? Will also annotate `enum` constants.
Default: `false`

| `jacksonTypeInfo` | `boolean` |  Should Java classes include `JsonTypeInfo` annotations for type hierarchies?
Default: `false`

| `jacksonUnion` | `boolean` |  Should Java classes include `JsonSerialize` and `@JsonDeserialize` 
annotations for union type wrappers?
Default: `false`

|===

== openapi Goal

|===
| Parameter     | Type          | Meaning

| `model`         | `String`        | RAML specification file, relative to `${project.basedir}`

| `outputDir`     | `File`          | Output directory for generated OpenAPI specifications. 
Default: `${project.build.directory}/ramler/openapi`

| `yaml` | `boolean` |  If true, the plugin creates an output file `<BASENAME>.yaml`, where `<BASENAME>` is
the base name of the RAML input model. E.g. `foo.raml -> foo.yaml`.
Default: `true`

| `json` | `boolean` |  If true, the plugin creates an output file `<BASENAME>.json`, where `<BASENAME>` is
the base name of the RAML input model. E.g. `foo.raml -> foo.json`.
Default: `false`

|===

== typescript Goal

|===
| Parameter     | Type          | Meaning

| `model`         | `String`        | RAML specification file, relative to `${project.basedir}`

| `outputDir`     | `File`          | Output directory for generated TypeScript sources. 
Default: `${project.build.directory}/ramler/ts`

|===


// Return to normal title levels 
:leveloffset: 0
